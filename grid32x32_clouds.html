<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>PixelMatix SmartMatrix</title>

    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="/bootstrap/3.1.1/css/bootstrap.min.css">

    <!-- Custom styles for this template -->
    <link href="/css/styles.css" rel="stylesheet">

    <!-- Load the Paper.js library -->
    <script type="text/javascript" src="http://paperjs.org/assets/js/paper.js"></script>
    <script type="text/javascript" src="/perlin.js"></script>
</head>
<body>
    <div class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="#">Pixelmatix SmartMatrix</a>
            </div>
            <div class="collapse navbar-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="/">Home</a></li>
                    <li><a href="grid32x32_dots.html">Dots</a></li>
                    <li><a href="images.html">Images</a></li>
                    <li class="active"><a href="grid32x32_clouds.html">Clouds</a></li>
                </ul>
            </div><!--/.nav-collapse -->
        </div>
    </div>

    <div class="container">
        <div class="main">
            <canvas id="myCanvas" resize></canvas>
        </div>
    </div>
    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
    <!-- Latest compiled and minified JavaScript -->
    <script src="/bootstrap/3.1.1/js/bootstrap.min.js"></script>

    <!-- Define inlined PaperScript, and associate it with myCanvas -->
    <script type="text/paperscript" canvas="myCanvas">

        /*
         * This is a self-contained for controlling Fadecandy from JavaScript.
         * We use the popular Paper.js library for drawing and vector math,
         * and we communicate with the LEDs via a WebSocket connection to fcserver.
         *
         * The fcserver must be running before loading the page.
         * Assumes an 32x32 LED matrix in top-down left-right order is connected
         * to the first channel of an attached Fadecandy board.
         *
         * This example is released into the public domain.
         * Feel free to use it as a starting point for your own projects.
         *
         * BROWSER SUPPORT:
         *   - Firefox: Works really well
         *   - Safari: Unusable. Runs for a few seconds, then stops.
         *   - Chrome: Pretty good, but not as fast as Firefox.
         *
         * 2013 Micah Elizabeth Scott
         */
        
        var dx, dy = 0.0;

        noise.seed(Math.random());

        // Paint the background black
        var background = new Path.Rectangle(view.bounds);
        background.fillColor = 'black';

        // Connect to a Fadecandy server running on the same computer, on the default port
        var socket = new WebSocket('ws://raspberrypi-jcoon:7890');

        // Put some connection status text in the corner of the screen
        var connectionStatus = new PointText(view.bounds.topLeft + new Point(8, 25));
        connectionStatus.content = 'Connecting to fcserver...';
        connectionStatus.style = {
            fontSize: 20,
            justification: 'left',
            fillColor: 'white'
        };
        socket.onclose = function(event) {
            connectionStatus.content = "Not connected to fcserver";
            connectionStatus.style.fillColor = '#f44';
        }
        socket.onopen = function(event) {
            connectionStatus.content = "Connected";
            connectionStatus.style.fillColor = '#4f4';
        }

        // Figure out which areas of the screen are going to map to our LEDs.
        // This example is hardcoded for an 32x32 grid of pixels, organized in a
        // left-to-right top-down fashion. Each LED is represented by a small
        // marker showing its location in the scene.

        var leds = []
        for (var y = 0; y < 32; y++) {
            for (var x = 0; x < 32; x++) {
                var spacing = view.bounds.height / 64;
                var point = view.center + new Point(spacing * (x - 16), spacing * (y - 16));
                var marker = new Path.Circle({
                    center: point,
                    radius: spacing * 0.25,
                    strokeColor: '#888',
                    strokeWidth: 1,
                    fillColor: 'black'
                });
                leds.push(marker);
            }
        }

        // Put the LEDs into a group, which we'll use later when we want to know the
        // bounding box around all of the sampling locations.

        var ledGroup = new Group(leds);

        // Use a Raster object to access the pixels we've drawn. This actually acts as
        // a proxy for the canvas, and it doesn't copy any data yet. We won't insert it
        // into the scene, otherwise we'd be redundantly drawing what we already drew
        // during every frame!

        var raster = new Raster({
            canvas: myCanvas,
            insert: false,
            position: view.center
        });

        // Things to do every frame...
        function onFrame(event) {
            // update
            var now = event.time * 1000.0;
            // console.log(now);
            var speed = 0.002;
            var angle = Math.sin(now * 0.001);
            var z = now * 0.00008;
            var hue = now * 0.01;
            var scale = 0.005;

            dx += Math.cos(angle) * speed;
            dy += Math.sin(angle) * speed;

            var i = 0;

            for (var x=0; x < 32; x++) {
                for (var y=0; y < 32; y++) {
                    var marker = leds[i];

                    var n = fractalNoise(dx + x*scale, dy + y*scale, z) - 0.75;
                    var m = fractalNoise(dx + x*scale, dy + y*scale, z + 10.0) - 0.75;

                    marker.fillColor.hue = (hue + 80.0 * m) % 100.0;
                    marker.fillColor.saturation = 100 - 100 * constrain(Math.pow(3.0 * n, 3.5), 0, 0.9);
                    marker.fillColor.brightness = 100 * constrain(Math.pow(3.0 * n, 1.5), 0, 0.9);
        
                    console.log(m + " " + n + " " + marker.fillColor.hue + " " + marker.fillColor.saturation + " " + marker.fillColor.brightness);
                    // marker.strokeColor = marker.fillColor;
                    
                    // leds[i] = marker;

                    i++;
                }
            }

            // Try to send a frame of LED data to fcserver
            writeFrameToServer();
        }

        function writeFrameToServer() {
            // Create an Open Pixel Control message to control our LEDs.
            // The fcserver socket treats text as JSON messages (Not used in
            // this example) and binary objects as Open Pixel Control packets.
            // The format of these messages are identical to the normal OPC
            // packets defined by openpixelcontrol.org, except that the "length"
            // bytes are reserved and should be sent as zero.
            //
            // OPC messages have a four byte header, indicating the channel, command,
            // and length. We want the "Set Pixel Colors" (0) command on channel 0,
            // so we can safely leave the 4-byte header initialized to zeroes,
            // and simply fill in the pixel data right after that in the buffer.
            //
            // Pixel data starts at offset 4 in the buffer, and we have a Red, Green,
            // and Blue byte for each LED.

            var packet = new Uint8ClampedArray(4 + leds.length * 3);

            if (socket.readyState != 1 /* OPEN */) {
                // The server connection isn't open. Nothing to do.
                return;
            }

            if (socket.bufferedAmount > packet.length) {
                // The network is lagging, and we still haven't sent the previous frame.
                // Don't flood the network, it will just make us laggy.
                // If fcserver is running on the same computer, it should always be able
                // to keep up with the frames we send, so we shouldn't reach this point.
                return;
            }

            // Capture an image of just the rectangle around all of our LEDs.
            var imageData = raster.getImageData(ledGroup.bounds);

            // Dest position in our packet. Start right after the header.
            var dest = 4;

            // Sample the center pixel of each LED
            for (var led = 0; led < leds.length; led++) {

                // Calculate the source position in imageData.
                // First, we find a vector relative to the LED bounding box corner.
                // Then we need to calculate the offset into the imageData array.
                // We need to do this with integer math (|0 coerces to integer quickly).
                // Also, note that imageData uses 4 bytes per pixel instead of 3.

                var srcVector = leds[led].position - ledGroup.bounds.topLeft;
                var src = 4 * ((srcVector.x|0) + (srcVector.y|0) * imageData.width);

                // Copy three bytes to our OPC packet, for Red, Green, and Blue
                packet[dest++] = imageData.data[src++];
                packet[dest++] = imageData.data[src++];
                packet[dest++] = imageData.data[src++];
            }

            socket.send(packet.buffer);
        }
        
        var noiseScale = 0.02;

        function fractalNoise(x, y, z) {
          var r = 0.0;
          var amp = 1.0;
          for (var octave = 0; octave < 4; octave++) {
            r += noise.simplex3(x, y, z) * amp;
            amp /= 2.0;
            x *= 2.0;
            y *= 2.0;
            z *= 2.0;
          }
          return r;
        }

        function constrain(val, min, max) {
            return Math.max(min, Math.min(val, max));
        }

    </script>

</body>
</html>